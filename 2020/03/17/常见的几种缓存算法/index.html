<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="William Chu"><meta name="description" content="�����ͼ�¼"><link rel="alternative" href="/atom.xml" title="William's Blog" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>常见的几种缓存算法 - William's Blog</title>
<link rel="stylesheet" href="/william.github.io/css/main.css">

<link rel="stylesheet" href="/william.github.io/js/fancybox/jquery.fancybox.min.css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]-->
<script src="/william.github.io/js/jquery-3.1.1.min.js"></script>

<script src="/william.github.io/js/fancybox/jquery.fancybox.min.js"></script>
<meta name="generator" content="Hexo 4.2.0"></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/william.github.io/">William's Blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/william.github.io/tags">标签</a></li><li class="head-nav__item"><a class="head-nav__link" href="/william.github.io/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2020-03-17T07:26:11.606Z">2020 - 03 - 17 15:26:11</time><h1 class="post__title"><a href="/william.github.io/2020/03/17/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/">常见的几种缓存算法</a></h1><div class="post__main echo"><h2 id="1-缓存相关概念"><a href="#1-缓存相关概念" class="headerlink" title="1.缓存相关概念"></a>1.缓存相关概念</h2><p>​        缓存 : 凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为缓存（Cache）。</p>
<p>​        因为内存相对于硬盘读写速度更快，内存可以作为硬盘的缓存；同样的，硬盘读写速度远高于网络数据的读写速度，也可以将硬盘作为网络数据的缓存。在内存和硬盘之间，硬盘与网络之间，都存在某种意义上的Cache。</p>
<p>​        表现上，缓存载体与被缓存载体总是相对的，缓存设备成本高于被缓存设备，缓存设备速度高于被缓存设备，缓存设备容量远远小于被缓存设备。</p>
<p>​        缓存可以认为是数据的池子，是存储频繁使用的数据的临时的地方，缓存可以认为是原始数据的子集，它是从原始数据里复制出来的，并且为了能被取回，被加上了标志。</p>
<h3 id="1-1-命中与回源"><a href="#1-1-命中与回源" class="headerlink" title="1.1.命中与回源"></a>1.1.命中与回源</h3><p>​        当用户发起一个请求，我们的应用接受这个请求，并且如果是在第一次检查缓存的时候，需要去数据库读取产品信息。如果在缓存中，一个条目通过一个标记被找到了，这个条目就会被使用、我们就叫它缓存命中。</p>
<p>​        如果没有命中缓存，就需要从原始地址获取，这个步骤叫做“回源”。回源的代价是高昂的，只有尽可能减少回源才能更好的发挥缓存的作用，但受限于缓存设备的成本，不能仅仅增加缓存容量，只能在成本和回源率之间寻求一个平衡点。</p>
<h3 id="1-2-缓存未命中-Cache-Miss"><a href="#1-2-缓存未命中-Cache-Miss" class="headerlink" title="1.2.缓存未命中(Cache Miss)"></a>1.2.缓存未命中(Cache Miss)</h3><p>​        如果还有缓存的空间，那么，没有命中的对象会被存储到缓存中来。</p>
<p>​        如果缓存满了，而又没有命中缓存，那么就会按照某一种策略，把缓存中的旧对象踢出，而把新的对象加入缓存池。而这些策略统称为替代策略（缓存算法），这些策略会决定到底应该踢出哪些对象。</p>
<h3 id="1-3-存储成本"><a href="#1-3-存储成本" class="headerlink" title="1.3.存储成本"></a>1.3.存储成本</h3><p>​        当没有命中时，我们会从数据库取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。</p>
<h3 id="1-4-失效"><a href="#1-4-失效" class="headerlink" title="1.4.失效"></a>1.4.失效</h3><p>​        当存在缓存中的数据需要更新时，就意味着缓存中的这个数据失效了。</p>
<h2 id="2-缓存算法"><a href="#2-缓存算法" class="headerlink" title="2. 缓存算法"></a>2. 缓存算法</h2><p>​        介于缓存只能够有限的使用内存，任何Cache系统都需要一个如何淘汰缓存的方案（缓存淘汰算法，等同于页面置换算法）。我们要根据自己的业务需要来选择使用何种算法来淘汰多余的数据，提高命中率。</p>
<p>常用的缓存算法有：</p>
<p><strong>LFU(Least Frequently Used)</strong></p>
<p>​        根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p><strong>1.LFU</strong></p>
<p>​        LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。</p>
<p>具体实现如下：</p>
<p><img src="http://note.youdao.com/yws/res/725/WEBRESOURCE6f6385c37579a9db7e68077d2a20e54a" alt="img"></p>
<p>​        假设我们的lfu最大的存储空间控制为5个，此时访问D,D现在的访问频率计数是26;</p>
<p>​        访问D后,D的频率+1,也就是27了。 此时需要调整缓存池数据需要重新排序,D和C交换;</p>
<p>​        访问B,B的频率+1,由于A的频率仍然比B大,所以不需要调整;</p>
<p>​        当新数据F插入缓存池之前,由于已经空间满了，需要干掉一个！ 因为E的频率最低,故淘汰E,将F插入缓存池,缓存池重新排序,F放到队尾.新加入数据插入到队列尾部（因为引用计数为1）队列中的数据被访问后，引用计数增加，队列重新排序,当需要淘汰数据时，将已经排序的列表最后的数据块删除</p>
<p><strong>LRU（LeastRecently User）</strong></p>
<p>​        根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p><strong>1.LRU</strong></p>
<p>​        最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</p>
<p><img src="http://note.youdao.com/yws/res/723/WEBRESOURCEb95bdb597cc12a0e2fa9f0919403dc70" alt="img"></p>
<p>​        新数据插入到链表头部；</p>
<p>​        每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</p>
<p>​        当链表满的时候，将链表尾部的数据丢弃。</p>
<p>​        当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p>
<p><strong>2.LRU-K(LeastRecently Used K)</strong></p>
<p>​        相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：</p>
<p><img src="http://note.youdao.com/yws/res/726/WEBRESOURCE15d31820f457dd5cd2e2a4db06d9a3dd" alt="img"></p>
<p>​        数据第一次被访问，加入到访问历史列表；</p>
<p>​        如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p>
<p>​        当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p>
<p>​        缓存数据队列中被再次访问后，重新排序；</p>
<p>​        需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p>
<p>​        LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。大多数情况下，LRU算法对热点数据命中率是很高的。 但如果突然大量偶发性的数据访问，会让内存中存放大量冷数据，也即是缓存污染。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>​        LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。</p>
<p><strong>FIFO(First inFirst out)</strong></p>
<p>​        最先进入的数据，最先被淘汰。一个很简单的算法。只要使用队列数据结构即可实现。那么FIFO淘汰算法基于的思想是”最近刚访问的，将来访问的可能性比较大”。</p>
<p><strong>2Q(Two Queues)</strong></p>
<p>​        同样也是为了解决LRU算法的缓存污染问题。类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。</p>
<p>​        当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：</p>
<p><img src="http://note.youdao.com/yws/res/724/WEBRESOURCE6a7e061c1c8fcfd77894caf077b8a212" alt="img"></p>
<p>​        新访问的数据插入到FIFO队列；</p>
<p>​        如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p>
<p>​        如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p>
<p>​        如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p>
<p>​        LRU队列淘汰末尾的数据。</p>
<p>注：上图中FIFO队列比LRU队列短，但并不代表这是算法要求，实际应用中两者比例没有硬性规定。</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/william.github.io/tags/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/">缓存算法</a></li><li class="post__tag__item"><a class="post__tag__link" href="/william.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/william.github.io/img/wechat.png" title="微信"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2016 - 2020 William Chu</div></footer>
<script src="/william.github.io/js/scroller.js"></script>

<script src="/william.github.io/js/main.js"></script>
</body></html>
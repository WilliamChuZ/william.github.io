{"meta":{"title":"William's Blog","subtitle":"个人博客","description":"分享和记录","author":"William Chu","url":"http://yoursite.com","root":"/william.github.io/"},"pages":[{"title":"404 Not Found","date":"2020-03-18T07:16:13.112Z","updated":"2020-03-18T07:16:13.112Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 �ܱ�Ǹ�������ʵ�ҳ�治���� �����������ַ�����õ�ַ�ѱ�ɾ��"},{"title":"关于","date":"2020-03-20T05:31:29.539Z","updated":"2020-03-20T05:31:29.539Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Java从业者"},{"title":"友情链接","date":"2020-03-20T06:18:07.881Z","updated":"2020-03-20T06:18:07.881Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-18T08:26:55.355Z","updated":"2020-03-18T08:26:55.355Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-18T07:12:54.631Z","updated":"2020-03-18T07:12:54.631Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-03-18T07:10:42.494Z","updated":"2020-03-18T07:10:42.494Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringMVC常用注解","slug":"SpringMVC常用注解","date":"2020-03-19T09:35:54.166Z","updated":"2020-03-19T09:57:30.513Z","comments":true,"path":"2020/03/19/SpringMVC常用注解/","link":"","permalink":"http://yoursite.com/2020/03/19/SpringMVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","excerpt":"Spring提供了一系列注解，有很多作用，此处对spring核心包注解和部分常用注解做归纳和总结。","text":"Spring提供了一系列注解，有很多作用，此处对spring核心包注解和部分常用注解做归纳和总结。 ** 组件型注解：**@Component 在类定义之前添加@Component注解，他会被spring容器识别，并转为bean。@Repository 对Dao实现类进行注解 (特殊的@Component)@Service 用于对业务逻辑层进行注解， (特殊的@Component)@Controller 用于控制层注解 ， (特殊的@Component)， 1.@Controller 在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。 @Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式： （1）在SpringMVC 的配置文件中定义MyController 的bean 对象。 （2）在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。 &lt;bean class=&quot;com.host.app.web.controller.MyController&quot;/&gt; &lt; context:component-scan base-package = &quot;com.host.app.web&quot; /&gt;//路径写到controller的上一层(扫描包详解见下面浅析)2.@RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。1、 value， method； value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）； method： 指定请求的method类型， GET、POST、PUT、DELETE等；2、consumes，produces consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；3、params，headers params： 指定request中必须包含某些参数值是，才让该方法处理。 headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 3.@Resource和@Autowired @Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。** 1、共同点** 两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。** 2、不同点**（1）@Autowired @Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。 class TestServiceImpl &#123;123456789 &#x2F;&#x2F; 下面两种@Autowired只要使用一种即可 @Autowired private UserDao userDao; &#x2F;&#x2F; 用于字段上 @Autowired public void setUserDao(UserDao userDao) &#123; &#x2F;&#x2F; 用于属性的方法上 this.userDao &#x3D; userDao; &#125;&#125; @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下： class TestServiceImpl &#123;1234 @Autowired @Qualifier(&quot;userDao&quot;) private UserDao userDao; &#125; （2）@Resource @Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。 class TestServiceImpl &#123;123456789 &#x2F;&#x2F; 下面两种@Resource只要使用一种即可 @Resource(name&#x3D;&quot;userDao&quot;) private UserDao userDao; &#x2F;&#x2F; 用于字段上 @Resource(name&#x3D;&quot;userDao&quot;) public void setUserDao(UserDao userDao) &#123; &#x2F;&#x2F; 用于属性的setter方法上 this.userDao &#x3D; userDao; &#125;&#125; 注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。@Resource装配顺序：①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 4.@ModelAttribute和 @SessionAttributes 代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。 @SessionAttributes即将值放到session作用域中，写在class上面。具体示例参见下面：使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据 5.@PathVariable 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如： 1234567891011121314151617181920public class TestController &#123; @RequestMapping(value&#x3D;&quot;&#x2F;user&#x2F;&#123;userId&#125;&#x2F;roles&#x2F;&#123;roleId&#125;&quot;,method &#x3D; RequestMethod.GET) public String getLogin(@PathVariable(&quot;userId&quot;) String userId, @PathVariable(&quot;roleId&quot;) String roleId)&#123; System.out.println(&quot;User Id : &quot; + userId); System.out.println(&quot;Role Id : &quot; + roleId); return &quot;hello&quot;; &#125; @RequestMapping(value&#x3D;&quot;&#x2F;product&#x2F;&#123;productId&#125;&quot;,method &#x3D; RequestMethod.GET) public String getProduct(@PathVariable(&quot;productId&quot;) String productId)&#123; System.out.println(&quot;Product Id : &quot; + productId); return &quot;hello&quot;; &#125; @RequestMapping(value&#x3D;&quot;&#x2F;javabeat&#x2F;&#123;regexp1:[a-z-]+&#125;&quot;, method &#x3D; RequestMethod.GET) public String getRegExp(@PathVariable(&quot;regexp1&quot;) String regexp1)&#123; System.out.println(&quot;URI Part 1 : &quot; + regexp1); return &quot;hello&quot;; &#125; &#125; 6.@requestParam @requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。 7.@ResponseBody 作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； 8.@Component 相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。 9.@Repository 用于注解dao层，在daoImpl类上面注解。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"Spring与SpringMVC的区别","slug":"Spring与SpringMVC的区别","date":"2020-03-19T09:28:11.474Z","updated":"2020-03-19T09:33:45.048Z","comments":true,"path":"2020/03/19/Spring与SpringMVC的区别/","link":"","permalink":"http://yoursite.com/2020/03/19/Spring%E4%B8%8ESpringMVC%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"1.Spring的介绍​ Spring是一个一站式的框架，提供了表现层（SpringMVC）到业务层（Spring）再到数据层（SpringData)的全套解决方案；Spring的两大核心是IOC与AOP，IOC（控制反转，Inversion of Control）与AOP（面向切面编程，Asepct-Orentid-Programming）为程序解耦和代码的简洁提供了支持。","text":"1.Spring的介绍​ Spring是一个一站式的框架，提供了表现层（SpringMVC）到业务层（Spring）再到数据层（SpringData)的全套解决方案；Spring的两大核心是IOC与AOP，IOC（控制反转，Inversion of Control）与AOP（面向切面编程，Asepct-Orentid-Programming）为程序解耦和代码的简洁提供了支持。目的：简化Java开发 功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能 范围：所有java应用 ​ Spring是个轻量级的控制反转和面向切面的容器框架，IOC与AOP可以单独用于任何应用，包括与Struts等MVC框架与Hibernate等ORM框架的集成。 2.SpringMVC的介绍​ SpringMVC给Spring的表现层提供支持 SpringMVC的流程： 用户发送请求至前端控制器DispatcherServlet； DispatcherServlet收到请求调用HandlerMapping处理器映射器； 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet； DispatcherServlet通过HandlerAdapter处理器适配器调用处理器，执行处理器(Controller，也叫后端控制器)； Controller执行完成返回ModelAndView，并返回给HandlerAdapter，HandlerAdapter将结果返回给DispatcherServlet； DispatcherServlet将ModelAndView传给ViewReslover视图解析器，ViewReslover解析后返回具体View给DispatcherServlet； DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）后返回给给客户 SpringMVC就是一个MVC模式的web开发框架，都属于Spring，SpringMVC需要有Spring的jar包作为支撑才能跑起来 3.AOP与IOC​ AOP与IOC给Spring的业务层提供支持，使程序松耦合，代码简洁AOP原理：即面向切面编程，就是提取公共部分，集中解决一些公共问题IOC原理：控制反转，在传统过程中，当某一个对象依赖于另一个对象时，会由该对象去创建另外一个对象。但是有了IOC之后，将创建过程交给IOC，由spring创建Bean，从而只需给该对象注入即可。 4.IOC与DI的区别与联系（1）IOC：控制反转（Inversion of Control） ​ 传统资源查找方式：要求组件向容器发起请求，查找资源作为回应，容器适时返回资源。​ IOC查找方式：容器主动将资源提供给它所管理的组件，组件只需要选择一个合适的方式来接收资源。​ 创建对象实例的控制权由代码控制转移到IOC容器控制（new关键字转移到容器），即在XML文件中控制，控制权转移即所谓的反转，侧重于原理。（2）DI：依赖注入（Dependecy Injection） ​ IOC另一种表达方式：组件以一些预先定义好的方式（如setter\\getter)接收来自容器的资源注入。相对于IOC，DI更直接创建对象实例时，为这个对象注入属性值和其他对象实例，侧重于实现。（3）属性注入 set方法注入bean的属性值或依赖的对象 name属性：制定bean属性set方法后的属性名 value属性：可以使（value)子节点指定属性值 （4）构造器注入 通过构造器注入bean属性值或依赖对象，它保证bean实例在实例化后可以使用 。（5）区别 他们是spring核心思想的不同方面的描述 依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是他们描述的角度不同 依赖注入是从应用程序的角度在描述，应用程序依赖容器创建并注入它所需要的外部资源 控制反转是从容器的角度在描述，容器控制应用程序，而容器反向的向应用程序注入应用程序所需要的外部资源","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC流程","slug":"SpringMVC流程","date":"2020-03-19T09:11:46.448Z","updated":"2020-03-19T09:26:27.924Z","comments":true,"path":"2020/03/19/SpringMVC流程/","link":"","permalink":"http://yoursite.com/2020/03/19/SpringMVC%E6%B5%81%E7%A8%8B/","excerpt":"SpringMVC是什么： SpringMVC是一个MVC的开源框架，SpringMVC=Struts2+Spring，SpringMVC就相当于是Struts2加上Spring的整合，但是这里有一个疑惑就是，SpringMVC和Spring是什么样的关系呢？","text":"SpringMVC是什么： SpringMVC是一个MVC的开源框架，SpringMVC=Struts2+Spring，SpringMVC就相当于是Struts2加上Spring的整合，但是这里有一个疑惑就是，SpringMVC和Spring是什么样的关系呢？这个在百度百科上有一个很好的解释：意思是说，SpringMVC是Spring的一个后续产品，其实就是Spring在原有基础上，又提供了Web应用的MVC模块，可以简单的把SpringMVC理解为是Spring的一个模块（类似AOP，IOC这样的模块），网络上经常会说SpringMVC和Spring无缝集成，其实SpringMVC就是Spring的一个子模块，所以根本不需要同Spring进行整合。 SpringMVC流程1、 用户发送请求至前端控制器DispatcherServlet。 2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4、 DispatcherServlet调用HandlerAdapter处理器适配器。 5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 6、 Controller执行完成返回ModelAndView。 7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 9、 ViewReslover解析后返回具体View。 10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 11、 DispatcherServlet响应用户。 组件说明：以下组件通常使用框架提供实现： DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。 ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。 组件：1、前端控制器DispatcherServlet作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 2、处理器映射器HandlerMapping作用：根据请求的url查找Handler HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 3、处理器适配器HandlerAdapter作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 4、处理器Handler注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。 5、视图解析器View resolver作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。 6、视图ViewView是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…） 核心架构的具体流程步骤如下： 1、首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制； 2、DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略； 3、DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器； 4、HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）； 5、ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术； 6、View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术； 7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。 下边两个组件通常情况下需要开发： Handler：处理器，即后端控制器用controller表示。 View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。 在将SpringMVC之前我们先来看一下什么是MVC模式 MVC：MVC是一种设计模式 MVC的原理图： 分析： M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity） V-View 视图（做界面的展示 jsp，html……） C-Controller 控制器（接收请求—&gt;调用模型—&gt;根据结果派发页面） SpringMVC原理图 看到这个图大家可能会有很多的疑惑，现在我们来看一下这个图的步骤：（可以对比MVC的原理图进行理解） 第一步:用户发起请求到前端控制器（DispatcherServlet） 第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找 第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain） 第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler） 第五步：处理器适配器去执行Handler 第六步：Handler执行完给处理器适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView 第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析 第九步：视图解析器像前端控制器返回View 第十步：前端控制器对视图进行渲染 第十一步：前端控制器向用户响应结果 看到这些步骤我相信大家很感觉非常的乱，这是正常的，但是这里主要是要大家理解springMVC中的几个组件： 前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。 处理器映射器（HandlerMapping）：根据URL去查找处理器 处理器（Handler）：（需要程序员去写代码处理逻辑的） 处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用） 视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"常见的几种缓存算法","slug":"常见的几种缓存算法","date":"2020-03-17T07:26:11.606Z","updated":"2020-03-19T09:34:22.121Z","comments":true,"path":"2020/03/17/常见的几种缓存算法/","link":"","permalink":"http://yoursite.com/2020/03/17/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/","excerpt":"缓存 : 凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为缓存（Cache）。","text":"缓存 : 凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为缓存（Cache）。 1.缓存相关概念​ ​ 因为内存相对于硬盘读写速度更快，内存可以作为硬盘的缓存；同样的，硬盘读写速度远高于网络数据的读写速度，也可以将硬盘作为网络数据的缓存。在内存和硬盘之间，硬盘与网络之间，都存在某种意义上的Cache。 ​ 表现上，缓存载体与被缓存载体总是相对的，缓存设备成本高于被缓存设备，缓存设备速度高于被缓存设备，缓存设备容量远远小于被缓存设备。 ​ 缓存可以认为是数据的池子，是存储频繁使用的数据的临时的地方，缓存可以认为是原始数据的子集，它是从原始数据里复制出来的，并且为了能被取回，被加上了标志。 1.1.命中与回源​ 当用户发起一个请求，我们的应用接受这个请求，并且如果是在第一次检查缓存的时候，需要去数据库读取产品信息。如果在缓存中，一个条目通过一个标记被找到了，这个条目就会被使用、我们就叫它缓存命中。 ​ 如果没有命中缓存，就需要从原始地址获取，这个步骤叫做“回源”。回源的代价是高昂的，只有尽可能减少回源才能更好的发挥缓存的作用，但受限于缓存设备的成本，不能仅仅增加缓存容量，只能在成本和回源率之间寻求一个平衡点。 1.2.缓存未命中(Cache Miss)​ 如果还有缓存的空间，那么，没有命中的对象会被存储到缓存中来。 ​ 如果缓存满了，而又没有命中缓存，那么就会按照某一种策略，把缓存中的旧对象踢出，而把新的对象加入缓存池。而这些策略统称为替代策略（缓存算法），这些策略会决定到底应该踢出哪些对象。 1.3.存储成本​ 当没有命中时，我们会从数据库取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。 1.4.失效​ 当存在缓存中的数据需要更新时，就意味着缓存中的这个数据失效了。 2. 缓存算法​ 介于缓存只能够有限的使用内存，任何Cache系统都需要一个如何淘汰缓存的方案（缓存淘汰算法，等同于页面置换算法）。我们要根据自己的业务需要来选择使用何种算法来淘汰多余的数据，提高命中率。 常用的缓存算法有： 2.1.LFU(Least Frequently Used)​ 根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。 LFU ​ LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。 具体实现如下： ​ 假设我们的lfu最大的存储空间控制为5个，此时访问D,D现在的访问频率计数是26; ​ 访问D后,D的频率+1,也就是27了。 此时需要调整缓存池数据需要重新排序,D和C交换; ​ 访问B,B的频率+1,由于A的频率仍然比B大,所以不需要调整; ​ 当新数据F插入缓存池之前,由于已经空间满了，需要干掉一个！ 因为E的频率最低,故淘汰E,将F插入缓存池,缓存池重新排序,F放到队尾.新加入数据插入到队列尾部（因为引用计数为1）队列中的数据被访问后，引用计数增加，队列重新排序,当需要淘汰数据时，将已经排序的列表最后的数据块删除 2.2.LRU（LeastRecently User）​ 根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 LRU ​ 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下： ​ 新数据插入到链表头部； ​ 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； ​ 当链表满的时候，将链表尾部的数据丢弃。 ​ 当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。 2.3.LRU-K(LeastRecently Used K)​ 相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下： ​ 数据第一次被访问，加入到访问历史列表； ​ 如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰； ​ 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序； ​ 缓存数据队列中被再次访问后，重新排序； ​ 需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。 ​ LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。大多数情况下，LRU算法对热点数据命中率是很高的。 但如果突然大量偶发性的数据访问，会让内存中存放大量冷数据，也即是缓存污染。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。 ​ LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。 2.4.FIFO(First inFirst out)​ 最先进入的数据，最先被淘汰。一个很简单的算法。只要使用队列数据结构即可实现。那么FIFO淘汰算法基于的思想是”最近刚访问的，将来访问的可能性比较大”。 2.5.2Q(Two Queues)​ 同样也是为了解决LRU算法的缓存污染问题。类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。 ​ 当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下： ​ 新访问的数据插入到FIFO队列； ​ 如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰； ​ 如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部； ​ 如果数据在LRU队列再次被访问，则将数据移到LRU队列头部； ​ LRU队列淘汰末尾的数据。 注：上图中FIFO队列比LRU队列短，但并不代表这是算法要求，实际应用中两者比例没有硬性规定。","categories":[{"name":"cache","slug":"cache","permalink":"http://yoursite.com/categories/cache/"}],"tags":[{"name":"缓存算法","slug":"缓存算法","permalink":"http://yoursite.com/tags/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-17T04:23:07.684Z","updated":"2020-03-18T09:49:06.383Z","comments":true,"path":"2020/03/17/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://yoursite.com/tags/Hello-World/"}]}]}